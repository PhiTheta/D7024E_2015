package dht

import (
	"encoding/json"
	"fmt"
	"net"
)

type DHTMsg struct {
	Key string `json:"key"`
	Src string `json:"src"`
	Dst string `json:"dst"`
	// Other?
<<<<<<< HEAD
	Req  string `json:"req"`
	Opt  string `json:"opt"`
	Data string `json:"data"`
	//Origin string `json:"origin"`
	//Bytes string `json:"bytes"`
}

=======
	Req  string `json:"req"` //request type
	Opt  string `json:"opt"` //option --
	Data string `json:"data"`//data string [key:ip:port]
	//Bytes string `json:"bytes"`
}

type Transport struct {
	node       *DHTNode
	bindAdress string
	queue      chan *DHTMsg
}

//Initiates Transport
func CreateTransport(dhtNode *DHTNode, bindAdress string) *Transport {
	transport := &Transport{}
	transport.bindAdress = bindAdress
	transport.node = dhtNode
	transport.queue = make(chan *DHTMsg)
	go transport.handler()
	return transport
}

//Creates Message with all info
>>>>>>> fba74b94cb9f90ad7f1ca98f48f4d3c5a7aecaa3
func CreateMsg(key string, src string, dst string, req string, opt string, data string) *DHTMsg {
	dhtMsg := &DHTMsg{}
	dhtMsg.Key = key
	dhtMsg.Src = src
	dhtMsg.Dst = dst
	dhtMsg.Req = req
	dhtMsg.Opt = opt
	dhtMsg.Data = data
	return dhtMsg
}

<<<<<<< HEAD
func (node *DHTNode) handler() {
=======
//Handles the different msg types from transport
func (transport *Transport) handler() {
>>>>>>> fba74b94cb9f90ad7f1ca98f48f4d3c5a7aecaa3
	for {
		select {
		case msg := <-node.queue:
			switch msg.Req {
			case "join":
				node.joinRing(msg)
			case "update":
				node.updateNode(msg)
			case "lookupResp":
				//fmt.Println("Response: " + msg.Data)
				//transport.nodest.setupFingers()
			case "fingerQuery":
				//fmt.Println(node.nodeId+":\t", msg)

				if node.responsible(msg.Opt) {
					fmt.Println(msg)
					node.fingerQuery(msg)
				} else {
					// Framtiden köra en accelerated forward?
					node.sendFrwd(msg, node.successor)
				}
				// Returnerna sig själv till source om typen är request. av typen fingerresponse
				// Vid typen response, lägg till den som finger.
			case "fingerResponse":

				node.fingerResponse(msg)
			case "printring":
				if msg.Opt != node.nodeId {
					node.send("printring", node.predecessor, msg.Opt, msg.Data+"->"+node.nodeId)
				} else {
					//fmt.Println(msg.Data)
				}
			case "printall":
				fingers := node.FingersToString()
				if msg.Opt != node.nodeId {
					node.send("printall", node.successor, msg.Opt, msg.Data+"\n"+node.predecessor.nodeId+"\t"+node.nodeId+"\t"+node.successor.nodeId+"\t"+fingers)
				} else {
					//fmt.Print("Pre.\tNode\tSucc.")
					//fmt.Print(msg.Data+"\n"+node.predecessor.nodeId+"\t"+node.nodeId+"\t"+node.successor.nodeId+"\t"+fingers+"\n", "")
				}
			}

		}
	}
}

<<<<<<< HEAD
func (node *DHTNode) listen() {
	udpAddr, err := net.ResolveUDPAddr("udp", node.bindAdress)
=======
//Listens for a connection
func (transport *Transport) listen() {
	udpAddr, err := net.ResolveUDPAddr("udp", transport.bindAdress)
>>>>>>> fba74b94cb9f90ad7f1ca98f48f4d3c5a7aecaa3
	conn, err := net.ListenUDP("udp", udpAddr)
	defer conn.Close()
	if err != nil {
		fmt.Println(err.Error())
	}
	dec := json.NewDecoder(conn)
	// fmt.Println("Started listening : " + node.bindAdress)
	Error("Started listening : " + node.bindAdress + "\n")

	for {
		msg := DHTMsg{}
		err = dec.Decode(&msg)
		if err != nil {
			fmt.Println(err.Error())
		}
		node.queue <- &msg
	}
}
<<<<<<< HEAD
=======

//Sends a msg
func (dhtNode *DHTNode) send(req string, dstNode *DHTNode, opt, data string) {

	msg := CreateMsg(dhtNode.nodeId, dhtNode.transport.bindAdress, dstNode.transport.bindAdress, req, opt, data)
	udpAddr, err := net.ResolveUDPAddr("udp", msg.Dst)
	conn, err := net.DialUDP("udp", nil, udpAddr)
	defer conn.Close()
	if err != nil {
		fmt.Println(err.Error())
	}
	res, _ := json.Marshal(msg)
	_, err = conn.Write(res) // wat?

}
>>>>>>> fba74b94cb9f90ad7f1ca98f48f4d3c5a7aecaa3
